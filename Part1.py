import matplotlib.pyplot as plt
import numpy as np, numpy

###############  PART ONE  ################

# Create a function which performs a piecewise Lagrange polynomial interpolation. It
#should take the polynomial degree, the knots and new evaluation points as
#input and return the interpolated data, all as numpy arrays. Your function should
#handle unevenly spaced data.

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.


############## IMPLEMENTATION ##############

#   x0, y0 are the x and y values of the knots, xEval is the list on which to
#evaluate returns the evaluation of xEval using the polynomial interpolation
#of given degree degree
#   If xEval is left empty, or if xEval is given as False, this will 
#not operate the interpolation itself, but instead pass back the function
#which can then be used by the user. 
def piecewiseLagrangePolynomialInterpolationFunction(x0, y0, xEval = False, degree = 3):

    # We have len(x0)-deg interpolants to obtain
    knotIntervalCount = len(x0) - degree
    pt1 = np.arange(degree+1)
    pts = pt1 + np.arange(knotIntervalCount).reshape(knotIntervalCount,1) # these are the sets of points we require

    #structure a as a two dimensional array 
    a = np.zeros((degree+1,knotIntervalCount))
    for i in range(knotIntervalCount):
        A = np.vander(x0[pts[i,:]])
        a[:,i] = np.linalg.solve(A,y0[pts[i,:]])

    powers = degree-np.arange(degree+1)


    def ThisLPInterpApproximation(inputPoint):

        if (inputPoint < min(x0)): # if we're outside of the interval, set k to extrapolate
            k = 0

        elif(inputPoint > max(x0)):
            k = len(x0)-1

        else:                # find k for x_i, accounting for the possibility that x_i=x_k
            k = np.where(((inputPoint<x0[1:]) & (inputPoint>=x0[:-1])) | 
                            ((x0[1:]==inputPoint) & (inputPoint>x0[:-1])))[0][0]

        # k is the left hand data point of our current subinterval; 
        # we need the polynomial with this point as the *centre*
    
        j = k - degree//2

        # account for j<0 or j>knotIntervalCount-1, i.e. at the edge
        j = np.maximum(0,j)
        j = np.minimum(j,knotIntervalCount-1)

        y = np.sum( a[:,j]*inputPoint ** powers)
        return y

    #If there was no evaluation set given, expose the interpolation function instead
    #Not sure if "expose" is the perfect term for this but it's a cool thing to do
    if( type(xEval) == bool and xEval == False ):
        return ThisLPInterpApproximation
    
    #Otherwise, just perform the function on the input set
    else:
        return numpy.array([ThisLPInterpApproximation(x) for x in xEval])


############## TESTING ##################


# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.

#given function
f = lambda x: (numpy.e)**x * numpy.cos(10*x)

N = 103
TestEvalX = np.linspace(-2,2,N)

M = 11
TestKnotX = np.linspace(-1,1,M)
TestKnotY = f(TestKnotX)

TestEvalY = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY, TestEvalX)

TestInterpFunction = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY)

TestEvalY = numpy.array([TestInterpFunction(x) for x in TestEvalX])


############## Plotting #################

plt.figure(figsize=(8,5))
plt.plot(TestEvalX,f(TestEvalX),label='exact function')
plt.plot(TestKnotX,TestKnotY,'kx',mew=2,label='data')
plt.plot(TestEvalX,TestEvalY,'.',label='polynomial interpolated')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(8,5))
plt.plot(TestEvalX,np.abs(f(TestEvalX)-TestEvalY),label='polynomial interpolated')
plt.xlabel('$x$')
plt.ylabel('$|y-p|$')
plt.title('Error')
plt.legend()
plt.tight_layout()
plt.show()
