import matplotlib.pyplot as plt
import numpy as np, numpy

###############  PART ONE  ################

# Create a function which performs a piecewise Lagrange polynomial interpolation. It
#should take the polynomial degree, the knots and new evaluation points as
#input and return the interpolated data, all as numpy arrays. Your function should
#handle unevenly spaced data.

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.


############## IMPLEMENTATION ##############

#returns !!! a function !!! that operates the polynomial. 
#degree is a positive int, knots is a list of coordinate pairs (x, y) 
def piecewiseLagrangePolynomialInterpolationFunction( knots, degree = 3 ):

	#put the knots into a dual list form for simplicity reasons
	knotsX = numpy.array([ knot[0] for knot in knots ])
	knotsY = numpy.array([ knot[1] for knot in knots ])

	M = len(knotsX)
	h = knotsX[2]-knotsX[1]

	# We have M-deg interpolants to obtain
	Nint = M - degree
	pt1 = np.arange(degree+1)
	pts = pt1 + np.arange(Nint).reshape(Nint,1) # these are the sets of points we require

	a = np.zeros((degree+1,Nint))
	for i in range(Nint):
		A = np.vander(knotsX[pts[i,:]])
		a[:,i] = np.linalg.solve(A,knotsY[pts[i,:]])

	pows = (degree-np.arange(degree+1))
	y = np.empty_like(x)

	h = (knotsX[-1]-knotsX[0])/(M-1)                  # assumed spacing
	
	# making sure we don't overshoot the last subinterval
	k = np.minimum(M-2,((x-x[0])/h).astype(int)) 

	j = k - degree//2    

	# account for j<0 or j>Nint-1, i.e. at the edge
	j = np.maximum(0,j)
	j = np.minimum(j,Nint-1)

	y = lambda evalArray: np.sum(a[:,j[:]]*(evalArray[:]**pows.reshape(degree+1,1)),axis=0)

	return y

#This is a wrapper function to preserve previous functionality
def piecewiseLagrangePolynomialInterpolation(knots, degree = 3, evaluationInterval = np.linspace(-1, 1, 101)):
	return piecewiseLagrangePolynomialInterpolationFunction( knots, degree )(evaluationInterval)



#The Test Function
#Generate the test x values
N = 101
a, b, c = -1, 1, 1.5
x = np.linspace(a,c,N) 

f = lambda x: (numpy.e)**x * numpy.cos(10*x)

testknots = [[x, f(x)] for x in np.linspace(a,b,11)]

y = piecewiseLagrangePolynomialInterpolation(testknots, 3)

plt.plot(x,f(x),label='exact function')
plt.plot([ knot[0] for knot in testknots ],[ knot[1] for knot in testknots ],'kx',mew=2,label='data')
plt.plot(x,y(x),'.',label='poly interpolated')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(8,5))
plt.plot(x,np.abs(f(x)-y(x)))
plt.xlabel('$x$')
plt.ylabel('$|y-p|$')
plt.title('Error')
plt.tight_layout()
plt.show()
	