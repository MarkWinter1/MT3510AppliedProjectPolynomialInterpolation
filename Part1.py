import matplotlib.pyplot as plt
import random
import numpy as np, numpy

###############  PART ONE  ################

# Create a function which performs a piecewise Lagrange polynomial interpolation. It
#should take the polynomial degree, the knots and new evaluation points as
#input and return the interpolated data, all as numpy arrays. Your function should
#handle unevenly spaced data.

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.


############## IMPLEMENTATION ##############

#   x0, y0 are the x and y values of the knots, xEval is the list on which to
#evaluate returns the evaluation of xEval using the polynomial interpolation
#of given degree degree
#   If xEval is left empty, or if xEval is given as False, this will 
#not operate the interpolation itself, but instead pass back the function
#which can then be used by the user. 
def piecewiseLagrangePolynomialInterpolationFunction(x0, y0, xEval = False, degree = 3):

    # We have len(x0)-deg interpolants to obtain
    knotIntervalCount = len(x0) - degree
    pt1 = np.arange(degree+1)
    pts = pt1 + np.arange(knotIntervalCount).reshape(knotIntervalCount,1) # these are the sets of points we require

    #structure a as a two dimensional array 
    a = np.zeros((degree+1,knotIntervalCount))
    for i in range(knotIntervalCount):
        A = np.vander(x0[pts[i,:]])
        a[:,i] = np.linalg.solve(A,y0[pts[i,:]])

    powers = degree-np.arange(degree+1)


    def ThisLPInterpApproximation(inputPoint):

        if (inputPoint < min(x0)): # if we're outside of the interval, set k to extrapolate
            k = 0

        elif(inputPoint > max(x0)):
            k = len(x0)-1

        else:                # find k for x_i, accounting for the possibility that x_i=x_k
            k = np.where(((inputPoint<x0[1:]) & (inputPoint>=x0[:-1])) | 
                            ((x0[1:]==inputPoint) & (inputPoint>x0[:-1])))[0][0]

        # k is the left hand data point of our current subinterval; 
        # we need the polynomial with this point as the *centre*
    
        j = k - degree//2

        # account for j<0 or j>knotIntervalCount-1, i.e. at the edge
        j = np.maximum(0,j)
        j = np.minimum(j,knotIntervalCount-1)

        y = np.sum( a[:,j]*inputPoint ** powers)
        return y

    #If there was no evaluation set given, expose the interpolation function instead
    #Not sure if "expose" is the perfect term for this but it's a cool thing to do
    if( type(xEval) == bool and xEval == False ):
        return ThisLPInterpApproximation
    
    #Otherwise, just perform the function on the input set
    else:
        return numpy.array([ThisLPInterpApproximation(x) for x in xEval])


############## TESTING ##################


# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.

#given function
f = lambda x: (numpy.e)**x * numpy.cos(10*x)

#constants and conditions
a, b, c, d = 0.9, 1.3, 0.9, 1.3
EvalPointCount = 500
KnotCount = 10

TestEvalX = np.linspace(c,d,EvalPointCount)

##Test One: delete some elements
#TestKnotX = np.linspace(-1,1,KnotCount)
#TestKnotX = numpy.delete(TestKnotX, [ random.choice([True, False]) for none in TestKnotX] ) 

##Test Two: generate knots randomly
#TestKnotX = numpy.array(sorted([random.uniform(a, b) for i in range(KnotCount)]))

##Test Three: actual given Test: Knots generated using a transformation on linear dist.
TestKnotX = 1/(1-np.linspace(0,1/6,KnotCount))

TestKnotY = numpy.array(f(TestKnotX))


TestEvalY = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY, TestEvalX)
##Note here that either of these generating methods for TestEvalY will work,
##Between asking the function to evaluate or taking the function and evaluating yourself
##In this case, the below code overwrites the above, just kept to show that both do work
TestInterpFunction = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY)
TestEvalY = numpy.array([TestInterpFunction(x) for x in TestEvalX])

#here for grading, don't like the variable names personally
x1 = TestEvalX
y1 = TestEvalY

############## Plotting #################

plt.plot(TestEvalX,f(TestEvalX), label='exact function')
plt.plot(TestKnotX,TestKnotY,'kx',mew=2,label='knots')
plt.plot(TestEvalX,TestEvalY, label='polynomial interpolated function')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

plt.plot(TestEvalX,f(TestEvalX)-TestEvalY)
plt.xlabel('$x$')
plt.ylabel('$|y-p|$')
plt.title('Signed Error')
plt.show()
