import matplotlib.pyplot as plt
import random
import numpy as np, numpy

###############  PART ONE  ################

# Create a function which performs a piecewise Lagrange polynomial interpolation. It
#should take the polynomial degree, the knots and new evaluation points as
#input and return the interpolated data, all as numpy arrays. Your function should
#handle unevenly spaced data.

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.

############## IMPLEMENTATION ##############

#   KnotX, KnotY are the x and y values of the knots, xEval is the list on which to
#evaluate returns the evaluation of xEval using the polynomial interpolation
#of given degree degree
#   If xEval is left empty, or if xEval is given as False, this will 
#not operate the interpolation itself, but instead pass what is effectively
#the polynomial function which can then be used by the user. 
def piecewiseLagrangePolynomialInterpolationFunction(KnotX, KnotY, xEval = False, degree = 3):

    # We have len(KnotX)-deg interpolants to obtain
    knotIntervalCount = len(KnotX) - degree
    pt1 = np.arange(degree+1)

    # these are the sets of points we require
    pts = pt1 + np.arange(knotIntervalCount).reshape(knotIntervalCount,1)

    #structure a as a two dimensional array with appropriate size
    a = np.empty((degree+1,knotIntervalCount))

    #iterate through the knots and populate a
    for i in range(knotIntervalCount):
        A = np.vander(KnotX[pts[i,:]])
        a[:,i] = np.linalg.solve(A,KnotY[pts[i,:]])

    powers = ( range(degree, -1, -1) )

    #now that all of the constants are calculated from the knots
    #make the polynomial into a function for user fun and pleasure
    def ThisLPInterpApproximation(inputPoint):

        #outside the knotted interval, k needs to be changed so the function can extrapolate
        if (inputPoint < min(KnotX)): 
            #set to 0 for below
            k = 0

        elif(inputPoint > max(KnotX)):
            #and to knot count-1 for above
            k = len(KnotX)-1

        else:
        #find k for x_i, accounting for the possibility that x_i=x_k
            k = np.where(((inputPoint<KnotX[1:]) & (inputPoint>=KnotX[:-1])) | ((KnotX[1:]==inputPoint) & (inputPoint>KnotX[:-1])))[0][0]

        # k is the left hand data point of our current subinterval; 
        # we need the polynomial with this point as the *centre*
    
        #start by setting j to be 
        j = k - degree//2

        # make sure j is greater than 0 and that j does not exceed the interval count
        j = min(max(0,j),knotIntervalCount-1)

        return np.sum( a[:,j]*inputPoint ** powers)

    #If there was no evaluation set given, expose the interpolation function instead
    #Not sure if "expose" is the perfect term for this but it's a cool thing to do
    if( type(xEval) == bool and xEval == False ):
        return ThisLPInterpApproximation
    
    #Otherwise, just perform the function on the input set, return the output
    else:
        return numpy.array([ThisLPInterpApproximation(x) for x in xEval])


############## TESTING ##################

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.

#given function
f = lambda x: (numpy.e)**x * numpy.cos(10*x)

#constants and conditions

#[a, b] is where knots are selected from, 
a, b = 0.9, 1.3
#how many knots
KnotCount = 10

#[c, d] is the region graphed and compared for error
c, d = 0.9, 1.3
#how many points
EvalPointCount = 100
#define the region graphed and checked for error 
TestEvalX = np.linspace(c,d,EvalPointCount)

##Test One: delete some elements
#TestKnotX = np.linspace(-1,1,KnotCount)
#TestKnotX = numpy.delete(TestKnotX, [ random.choice([True, False]) for none in TestKnotX] ) 

##Test Two: generate knots randomly
#TestKnotX = numpy.array(sorted([random.uniform(a, b) for i in range(KnotCount)]))

##Test Three: actual given Test: Knots generated using a transformation on linear dist.
TestKnotX = 1/(1-np.linspace(0,1/6,KnotCount))
TestKnotY = numpy.array(f(TestKnotX))


TestEvalY = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY, TestEvalX)
##Note here that either of these generating methods for TestEvalY will work,
##Between asking the function to evaluate or taking the function and evaluating yourself
##In this case, the below code overwrites the above, just kept to show that both do work
TestInterpFunction = piecewiseLagrangePolynomialInterpolationFunction(TestKnotX, TestKnotY)
TestEvalY = numpy.array([TestInterpFunction(x) for x in TestEvalX])

#here for grading, don't like the variable names personally
x1 = TestEvalX
y1 = TestEvalY

############## Plotting #################
fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, sharex=True)

ax1.set_title('Piecewise Lagrange Polynomial Interpolation of e^x cos(10x)')
ax1.set_ylabel('y')
ax1.plot(TestEvalX,f(TestEvalX), label='exact function')
ax1.plot(TestKnotX,TestKnotY,'kx',mew=2,label='knots')
ax1.plot(TestEvalX,TestEvalY, label='polynomial interpolated function')
plt.xlabel('x')
ax1.legend()

ax2.set_ylabel('$|y-p|$')
ax2.set_title('Signed Error')
ax2.plot(TestEvalX,f(TestEvalX)-TestEvalY, label='Signed Error')
ax2.legend()
plt.show()