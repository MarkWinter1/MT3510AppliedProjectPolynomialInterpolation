import matplotlib.pyplot as plt
import numpy as np, numpy

###############  PART ONE  ################

# Create a function which performs a piecewise Lagrange polynomial interpolation. It
#should take the polynomial degree, the knots and new evaluation points as
#input and return the interpolated data, all as numpy arrays. Your function should
#handle unevenly spaced data.

# Validate this function using test knots generated by the function
#stored in x1 and y1 created via the following code, and choosing appropriate new
#evaluation points yourself.


############## IMPLEMENTATION ##############

#x0, y0 are the x and y values of the knots, xEval is the list on which to evaluate
#returns the evaluation of xEval using the polynomial interpolation
def piecewiseLagrangePolynomialInterpolationFunction(x0, y0, xEval, degree = 3):
    Ndeg = degree
    M = len(x0)
    N = len(xEval)

    # We have M-deg interpolants to obtain
    Nint = M - Ndeg
    pt1 = np.arange(Ndeg+1)
    pts = pt1 + np.arange(Nint).reshape(Nint,1) # these are the sets of points we require

    #structure a
    a = np.zeros((Ndeg+1,Nint))
    for i in range(Nint):
        A = np.vander(x0[pts[i,:]])
        a[:,i] = np.linalg.solve(A,y0[pts[i,:]])

    y = np.empty_like(xEval)     # set up new data points
    pows = Ndeg-np.arange(Ndeg+1)

    for i in range(N):       # loop over new evaluation points

        if((xEval[i]<x0).all()): # if we're outside of the interval, set k to extrapolate
            k = 0
        elif((xEval[i]>x0).all()):
            k = M-1
        else:                # find k for x_i, accounting for the possibility that x_i=x_k
            k = np.where(((xEval[i]<x0[1:]) & (xEval[i]>=x0[:-1])) | 
                         ((x0[1:]==xEval[i]) & (xEval[i]>x0[:-1])))[0][0]

        # k is the left hand data point of our current subinterval; 
        # we need the polynomial with this point as the *centre*
    
        j = k - Ndeg//2    

        # account for j<0 or j>Nint-1, i.e. at the edge
        j = np.maximum(0,j)
        j = np.minimum(j,Nint-1)

        y[i] = np.sum(a[:,j]*xEval[i]**pows)
    
    return y